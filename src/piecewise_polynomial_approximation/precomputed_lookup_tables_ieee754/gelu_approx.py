import torch
import torch.nn as nn

intervals = [-5.0, -2.5, -0.15625, 0.0, 0.01953125, 1.25, 2.5, 5.0]
coefficients = [[1.2895795908505931, 4.073032928092294, 4.691033359435142, 2.8792384611697766, 1.0791053808187339, 0.2608666143636282, 0.041087059353728285, 0.0040900639099147006, 0.00023438858468830207, 5.90604030893164e-06], [2.376964334259458e-05, 0.5004288463693577, 0.4019796647312853, 0.01115437345667799, -0.04298357850623199, 0.03138001709020909, 0.03609092122422064, 0.012964912261139005, 0.002151162086647903, 0.00014133215099371626], [0.0, 0.500047294054841, 0.4008615346915292, 0.020747805925992003, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.4999999066695583, 0.39897254490941747, -0.002609874565159166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.1533207267459995e-08, 0.49999750610410826, 0.3989953958419841, -0.00044939766006271155, -0.06493564785867448, -0.00436799659271878, 0.016032685784881543, -0.004354770903614359, 0.00027420682898949606, 0.0], [-0.013522252099503085, 0.5726799362687146, 0.22874982691937126, 0.22503129069812494, -0.2469670374184168, 0.0842691270130255, -0.006936728923590485, -0.002835398155777195, 0.0007817717474103859, -6.0314410051684345e-05], [1.2895795528868774, -3.0730328404499914, 4.691033270833635, -2.8792384097069217, 1.0791053618983795, -0.26086660979880494, 0.041087058631132364, -0.004090063837550869, 0.00023438858052764753, -5.906040204240664e-06]]

def approx_gelu(x: torch.Tensor) -> torch.Tensor:
    out = torch.empty_like(x)

    def poly_eval(z: torch.Tensor, coeffs):
        # Evaluate the polynomial sum of coeffs[k] * z^k
        result = torch.zeros_like(z)
        for power, c in enumerate(coeffs):
            result += c * (z ** power)
        return result

    num_intervals = len(intervals)
    for i in range(num_intervals - 1):
        lower = intervals[i]
        upper = intervals[i + 1]
        mask = (x >= lower) & (x < upper)
        out[mask] = poly_eval(x[mask], coefficients[i])

    # Values >= the last boundary
    mask_last = (x >= intervals[-1])
    out[mask_last] = poly_eval(x[mask_last], coefficients[-1])

    # Values < the first boundary
    mask_first = (x < intervals[0])
    out[mask_first] = poly_eval(x[mask_first], coefficients[0])

    return out
